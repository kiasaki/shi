(environment-set '*module* 'shi:core:prelude)

(environment-set (environment-root) 'set (macro (name value)
  (list 'environment-set (list 'quote name) value)))

(environment-set (environment-root) 'def (macro (name value)
  (list 'do
    (list 'set 'gs#def-name (list 'sym (list 'str '*module* ":" (list 'quote name))))
    (list 'set 'gs#def-value value)
    (list 'environment-set '(environment-root) 'gs#def-name 'gs#def-value)
    (list 'environment-set (list 'quote name) 'gs#def-value))))

(def def- set)

(def null? (fn (x) (eq "null" (type x))))
(def bool? (fn (x) (eq "boolean" (type x))))
(def true? (fn (x) (eq true x)))
(def false? (fn (x) (eq false x)))
(def str? (fn (x) (eq "string" (type x))))
(def list? (fn (x) (eq "list" (type x))))
(def vec? (fn (x) (eq "vector" (type x))))
(def sym? (fn (x) (eq "symbol" (type x))))
(def int? (fn (x) (eq "integer" (type x))))
(def float? (fn (x) (eq "float" (type x))))
(def stream? (fn (x) (eq "stream" (type x))))
(def map? (fn (x) (eq "map" (type x))))
(def builtin? (fn (x) (eq "builtin" (type x))))
(def closure? (fn (x) (eq "closure" (type x))))
(def macro? (fn (x) (eq "macro" (type x))))
(def environment? (fn (x) (eq "environment" (type x))))

(def empty? (fn (x) (eq (list-length x) 0)))

(def len list-length)
(def append list-join)
(def first (fn (x)
  (cond
    (empty? x) null
    else (list-nth 0 x))))
(def second (fn (x)
  (cond
    (< 2 (len x)) null
    else (list-nth 1 x))))
(def head first)
(def tail (fn (x) (list-slice 1 x)))
(def init (fn (x) (list-slice 0 (- (len x) 1) x)))

(def last (fn (x)
  (cond
    (empty? x) null
    else (list-nth (- (len x) 1) x))))

(def if (macro (test then & else)
  (list 'cond test then 'else (head else))))

(def cons (fn (x l) (list-join (list x) (if (null? l) '() l))))

(def apply (macro (f args) (cons f args)))

(def and (macro (& args)
  (cond
    (empty? args) true
    (empty? (tail args)) (head args)
    else (list 'if (head args) (cons 'and (tail args)) false))))

(def not (fn (x)
  (if (eq x false)
      true
      (if (eq x null)
          true
          false))))

(def pair? (fn (x) (eq (mod x 2) 0)))
(def odd? (fn (x) (not (pair? x))))

;(set qq-expand (fn (exp)
;  (set constant? (fn (exp)
;    (if (list? exp)
;      (eq (head exp) 'quote)
;      (not (sym? exp)))))
;
;  (set combine-skeletons (fn (left right exp)
;    (cond
;      (and (constant? left) (constant? right))
;      (if (and (eql (eval left) (head exp)) (eql (eval right) (tail exp)))
;        (list 'quote exp)
;        (list 'quote (cons (eval left) (eval right))))
;      (null? right) (list 'list left)
;      (and (list? right) (eq (head right) 'list))
;      (cons 'list (cons left (tail right)))
;      else (list 'cons left right))))
;
;  (set expand-quasiquote (fn (exp nesting)
;    (cond
;      (vec? exp)
;      (list 'apply 'vec (expand-quasiquote (vec->list exp) nesting))
;      (not (list? exp))
;      (if (constant? exp) exp (list 'quote exp))
;      (and (eq (head exp) 'unquote) (eq (len exp) 2))
;      (if (eq nesting 0)
;        (second exp)
;        (combine-skeletons ''unquote (expand-quasiquote (tail exp) (- nesting 1)) exp))
;      (and (eq (head exp) 'quasiquote) (eq (len exp) 2))
;      (combine-skeletons ''quasiquote (expand-quasiquote (tail exp) (+ nesting 1)) exp)
;      (and (list? (head exp))
;        (eq (head (head exp)) 'unquote-splicing)
;        (eq (len (head exp)) 2))
;      (if (eq nesting 0)
;        (list 'append (second (first exp))
;          (expand-quasiquote (tail exp) nesting))
;        (combine-skeletons (expand-quasiquote (head exp) (- nesting 1))
;          (expand-quasiquote (tail exp) nesting)
;          exp))
;      else (combine-skeletons
;              (expand-quasiquote (head exp) nesting)
;              (expand-quasiquote (tail exp) nesting)
;              exp))))
;
;    (expand-quasiquote exp 0)))

;(set quasiquote (macro (exp) (qq-expand exp)))


(set qq-expand-list (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (list 'list (second exp))
        (eq 'unquote-splicing (head exp))
          (second exp)
        (eq 'quasiquote (head exp))
          (qq-expand-list (qq-expand (second exp)))
        else
          (list 'list (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp)))))
    else
      (list 'list exp))))

(def qq-expand (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (vec? exp)
      (list 'apply 'vec (qq-expand (vec->list exp) nesting))
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (second exp)
        (eq 'unquote-splicing (head exp))
          (error "illegal unquote-splicing at quasiquote root")
        (eq 'quasiquote (head exp))
          (qq-expand (qq-expand (second exp)))
        else
          (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp))))
    else exp)))

(def quasiquote (macro (exp)
  (qq-expand exp)))

(def unquote (fn (& _) (error "unquote called outside of quasiquote")))
(def unquote-splicing (fn (& _) (error "unquote-splicing called outside of quasiquote")))

(def defmacro
  (macro (name args & body)
    `(do (def ,name (macro ,name ,args ,@body))
         ',name)))

(defmacro defn (name args & body)
  `(do (def ,name (fn ,name ,args ,@body))
       ',name))

(set *gensym-counter* 0)
(defn gensym ()
  (set *gensym-counter* (+ 1 *gensym-counter*))
  (sym (str "gs#" (pr-str *gensym-counter*))))

(defmacro or (& args)
  (if (empty? args)
    false
    (let (x (gensym))
      `(do
          (set ,x ,(first args))
          (if ,x ,x (apply or ,(tail args)))))))

(defn atom? (x)
  (or (null? x) (bool? x) (str? x) (int? x) (float? x)))

(defn identity (x) x)

(defn > (x y) (< y x))
(defn >= (x y) (not (< x y)))
(defn <= (x y) (not (< y x)))
(defn /= (x y) (not (eql x y)))

;(defmacro if (test then & else)
;  `(cond (,test ,then)
;         ,@(cond (else `((true ,@else))))))
;

(defmacro when (test & body)
  `(cond ,test (do ,@body)))

(defmacro let (args & body)
  (if (odd? (len args))
    (error "let: odd number of values given in assignments"))
  (set vars (fn (xs)
    (loop (i 0
           vs (list))
      (if (>= i (len xs))
        vs
        (recur (+ i 2) (append vs (list (list-nth i xs))))))))
  (set vals (fn (xs)
    (loop (i 1
           vs (list))
      (if (>= i (len xs))
        vs
        (recur (+ i 2) (append vs (list (list-nth i xs))))))))
  `((fn ,(vars args) ,@body) ,@(vals args)))

(defmacro module (name)
  `(environment-set "*module*" ',name))

(defn import-in (top-env name alias)
  (loop (syms (environment-symbols (environment-root)))
    (when (head syms)
      (let (s-parts (str-split ":" (str (head syms)))
            s-val (environment-get (head syms)))
        (when (eq name (str-join ":" (init s-parts)))
          (if (eq alias ".")
            (environment-set top-env (last s-parts) s-val)
            (environment-set top-env (str alias ":" (last s-parts)) s-val))))
      (recur (tail syms)))))

(defmacro import (name & args)
  (set alias (last (str-split ":" (str name))))
  (if (and (not (empty? args)) (sym? (head args)))
    (set alias (str (head args))))
  `(import-in *env* (str name) ,alias))
