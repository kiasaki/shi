(environment-set (environment-root) def (macro (name value)
  (list 'environment-set '(environment-root) name value)))

(def set (macro (name value)
  (list 'environment-set name value)))

(def null? (fn (x) (eq "null" (type x))))
(def list? (fn (x) (eq "list" (type x))))
(def symbol? (fn (x) (eq "symbol" (type x))))
(def vector? (fn (x) (eq "vector" (type x))))

(def empty? (fn (x) (eq 0 (list-length x))))

(def first (fn (x) (list-nth 0 x)))
(def second (fn (x) (list-nth 1 x)))
(def head (fn (x)
  (cond
    (empty? x) null
    else (list-nth 0 x))))
(def tail (fn (x) (list-slice 1 x)))

(def length list-length)
(def append list-join)

(def if (macro (test then else)
  (list 'cond test then 'else else)))

(def and (macro (& args)
  (cond
    (empty? args) true
    (empty? (tail args)) (head args)
    else (list 'if (head args) (cons 'and (tail args)) false))))

(def not (fn (x)
  (if (eq x false)
      true
      (if (eq x null)
          true
          x))))

;(set qq-expand (fn (exp)
;  (set constant? (fn (exp)
;    (if (list? exp)
;      (eq (head exp) 'quote)
;      (not (symbol? exp)))))
;
;  (set combine-skeletons (fn (left right exp)
;    (cond
;      (and (constant? left) (constant? right))
;      (if (and (eql (eval left) (head exp)) (eql (eval right) (tail exp)))
;        (list 'quote exp)
;        (list 'quote (cons (eval left) (eval right))))
;      (null? right) (list 'list left)
;      (and (list? right) (eq (head right) 'list))
;      (cons 'list (cons left (tail right)))
;      else (list 'cons left right))))
;
;  (set expand-quasiquote (fn (exp nesting)
;    (cond
;      (vector? exp)
;      (list 'apply 'vec (expand-quasiquote (vector->list exp) nesting))
;      (not (list? exp))
;      (if (constant? exp) exp (list 'quote exp))
;      (and (eq (head exp) 'unquote) (eq (length exp) 2))
;      (if (eq nesting 0)
;        (second exp)
;        (combine-skeletons ''unquote (expand-quasiquote (tail exp) (- nesting 1)) exp))
;      (and (eq (head exp) 'quasiquote) (eq (length exp) 2))
;      (combine-skeletons ''quasiquote (expand-quasiquote (tail exp) (+ nesting 1)) exp)
;      (and (list? (head exp))
;        (eq (head (head exp)) 'unquote-splicing)
;        (eq (length (head exp)) 2))
;      (if (eq nesting 0)
;        (list 'append (second (first exp))
;          (expand-quasiquote (tail exp) nesting))
;        (combine-skeletons (expand-quasiquote (head exp) (- nesting 1))
;          (expand-quasiquote (tail exp) nesting)
;          exp))
;      else (combine-skeletons
;              (expand-quasiquote (head exp) nesting)
;              (expand-quasiquote (tail exp) nesting)
;              exp))))
;
;    (expand-quasiquote exp 0)))

;(set quasiquote (macro (exp) (qq-expand exp)))


(set qq-expand-list (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (list 'list (second exp))
        (eq 'unquote-splicing (head exp))
          (second exp)
        (eq 'quasiquote (head exp))
          (qq-expand-list (qq-expand (second exp)))
        else
          (list 'list (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp)))))
    else
      (list 'list exp))))

(def qq-expand (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (vector? exp)
      (list 'apply 'vec (expand-quasiquote (vector->list exp) nesting))
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (second exp)
        (eq 'unquote-splicing (head exp))
          (error "illegal unquote-splicing at quasiquote root")
        (eq 'quasiquote (head exp))
          (qq-expand (qq-expand (second exp)))
        else
          (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp))))
    else exp)))

(def quasiquote (macro (exp)
  (qq-expand exp)))

(def unquote (fn (& _) (error "unquote called outside of quasiquote")))
(def unquote-splicing (fn (& _) (error "unquote-splicing called outside of quasiquote")))

(def defmacro
  (macro (name args & body)
    `(do (def ,name (macro ,args ,@body))
         ',name)))

(defmacro defn (name args & body)
  `(do (def ,name (fn ,args ,@body))
       ',name))

(set *gensym-counter* 0)
(defn gensym ()
  (set *gensym-counter* (+ 1 *gensym-counter*))
  (sym (str "gs#" (pr-str *gensym-counter*))))

(defmacro or (& args)
  (if (empty? args)
    false
    (let (x (gensym))
      `(do
          (set ,x ,(first args))
          (if ,x ,x (apply or ,(tail args)))))))

(defn identity (x) x)

(defn > (x y) (< y x))
(defn >= (x y) (not (< x y)))
(defn <= (x y) (not (< y x)))
(defn /= (x y) (not (eql x y)))

;(defmacro if (test then & else)
;  `(cond (,test ,then)
;         ,@(cond (else `((true ,@else))))))
;
;(defmacro when (test & body)
;  `(cond (,test ,@body)))
;
;(defmacro let (args & body)
;  ((fn (vars vals)
;     (defn vars (x)
;       (cond (x (cons (if (atom (car x))
;                          (car x)
;                        (caar x))
;                      (vars (cdr x))))))
;     (defn vals (x)
;       (cond (x (cons (if (atom (car x))
;                          nil
;                        (cadar x))
;                      (vals (cdr x))))))
;     `((lambda ,(vars args) ,@body) ,@(vals args)))
;   nil nil))
