(environment-set def (macro (name value)
  (list 'environment-set '(environment-root) name value)))

(environment-set set (macro (name value)
  (list 'environment-set name value)))

(set null? (fn (x) (eq "null" (type x))))
(set list? (fn (x) (eq "list" (type x))))
(set symbol? (fn (x) (eq "symbol" (type x))))
(set vector? (fn (x) (eq "vector" (type x))))

(set empty? (fn (x) (eq 0 (list-length x))))

(set first (fn (x) (list-nth 0 x)))
(set second (fn (x) (list-nth 1 x)))
(set head (fn (x)
  (cond
    (empty? x) null
    else (list-nth 0 x))))
(set tail (fn (x) (list-slice 1 x)))

(set length list-length)
(set append list-join)

(set if (macro (test then else)
  (list 'cond test then 'else else)))

(set and (macro (& args)
  (cond
    (empty? args) true
    (empty? (tail args)) (head args)
    else (list 'if (head args) (cons 'and (tail args)) false))))

(set not (fn (x)
  (if (eq x false)
      true
      (if (eq x null)
          true
          x))))

;(set qq-expand (fn (exp)
;  (set constant? (fn (exp)
;    (if (list? exp)
;      (eq (head exp) 'quote)
;      (not (symbol? exp)))))
;
;  (set combine-skeletons (fn (left right exp)
;    (cond
;      (and (constant? left) (constant? right))
;      (if (and (eql (eval left) (head exp)) (eql (eval right) (tail exp)))
;        (list 'quote exp)
;        (list 'quote (cons (eval left) (eval right))))
;      (null? right) (list 'list left)
;      (and (list? right) (eq (head right) 'list))
;      (cons 'list (cons left (tail right)))
;      else (list 'cons left right))))
;
;  (set expand-quasiquote (fn (exp nesting)
;    (cond
;      (vector? exp)
;      (list 'apply 'vec (expand-quasiquote (vector->list exp) nesting))
;      (not (list? exp))
;      (if (constant? exp) exp (list 'quote exp))
;      (and (eq (head exp) 'unquote) (eq (length exp) 2))
;      (if (eq nesting 0)
;        (second exp)
;        (combine-skeletons ''unquote (expand-quasiquote (tail exp) (- nesting 1)) exp))
;      (and (eq (head exp) 'quasiquote) (eq (length exp) 2))
;      (combine-skeletons ''quasiquote (expand-quasiquote (tail exp) (+ nesting 1)) exp)
;      (and (list? (head exp))
;        (eq (head (head exp)) 'unquote-splicing)
;        (eq (length (head exp)) 2))
;      (if (eq nesting 0)
;        (list 'append (second (first exp))
;          (expand-quasiquote (tail exp) nesting))
;        (combine-skeletons (expand-quasiquote (head exp) (- nesting 1))
;          (expand-quasiquote (tail exp) nesting)
;          exp))
;      else (combine-skeletons
;              (expand-quasiquote (head exp) nesting)
;              (expand-quasiquote (tail exp) nesting)
;              exp))))
;
;    (expand-quasiquote exp 0)))

;(set quasiquote (macro (exp) (qq-expand exp)))


(set qq-expand-list (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (list 'list (second exp))
        (eq 'unquote-splicing (head exp))
          (second exp)
        (eq 'quasiquote (head exp))
          (qq-expand-list (qq-expand (second exp)))
        else
          (list 'list (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp)))))
    else
      (list 'list exp))))

(set qq-expand (fn (exp)
  (cond
    (and (list? exp) (empty? exp))
      exp
    (vector? exp)
      (list 'apply 'vec (expand-quasiquote (vector->list exp) nesting))
    (list? exp)
      (cond
        (eq 'unquote (head exp))
          (second exp)
        (eq 'unquote-splicing (head exp))
          (error "illegal unquote-splicing at quasiquote root")
        (eq 'quasiquote (head exp))
          (qq-expand (qq-expand (second exp)))
        else
          (list 'append (qq-expand-list (head exp)) (qq-expand (tail exp))))
    else exp)))

(set quasiquote (macro (exp)
  (qq-expand exp)))

(set unquote (fn (& _) (error "unquote called outside of quasiquote")))
(set unquote-splicing (fn (& _) (error "unquote-splicing called outside of quasiquote")))

(set defmacro
  (macro (name args & body)
    `(do (set ,name (macro ,args ,@body))
         ',name)))

(defmacro defn (name args & body)
  `(do (set ,name (fn ,args ,@body))
       ',name))

(set *gensym-counter* 0)
(defn gensym ()
  (set *gensym-counter* (+ 1 *gensym-counter*))
  (sym (str "gs#" (pr-str *gensym-counter*))))

(defmacro or (& args)
  (if (empty? args)
    false
    (let (x (gensym))
      `(do
          (set ,x ,(first args))
          (if ,x ,x (apply or ,(tail args)))))))

(defn identity (x) x)

(defn > (x y) (< y x))
(defn >= (x y) (not (< x y)))
(defn <= (x y) (not (< y x)))
(defn /= (x y) (not (eql x y)))

;(defmacro if (test then & else)
;  `(cond (,test ,then)
;         ,@(cond (else `((true ,@else))))))
;
;(defmacro when (test & body)
;  `(cond (,test ,@body)))
;
;(defmacro let (args & body)
;  ((fn (vars vals)
;     (defn vars (x)
;       (cond (x (cons (if (atom (car x))
;                          (car x)
;                        (caar x))
;                      (vars (cdr x))))))
;     (defn vals (x)
;       (cond (x (cons (if (atom (car x))
;                          nil
;                        (cadar x))
;                      (vals (cdr x))))))
;     `((lambda ,(vars args) ,@body) ,@(vals args)))
;   nil nil))
