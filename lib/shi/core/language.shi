(set null? (fn (x) (eql "null" (type x))))
(set list? (fn (x) (eql "cell" (type x))))
(set symbol? (fn (x) (eql "symbol" (type x))))
(set vector? (fn (x) (eql "vector" (type x))))

(set not (fn (x) (eq x false)))

(set first (fn (x) (list-nth 0)))
(set second (fn (x) (list-nth 1)))
(set head (fn (x) (list-nth 0)))
(set tail (fn (x) (list-slice 1 x)))

(set cons list-prepend)
(set length list-length)
(set append list-join)

(set if (macro (test then else)
  (list 'cond (list test then) (list 'else else))))

(define or (macro (& args)
  (if (null? args)
    false
    (cons 'cond (map list args)))))

(set and (macro (& args)
  (cond
    ((null? args) true)
    ((null? (tail args)) (head args))
    (else (list 'if (head args) (cons 'and (tail args)) false)))))

(set quasiquote
  (macro (x)
    (set constant? (fn (exp)
      (if (cell? exp)
        (eq (head exp) 'quote)
        (not (symbol? exp)))))

    (set combine-skeletons (fn (left right exp)
      (cond
       ((and (constant? left) (constant? right))
        (if (and (eql (eval left) (head exp)) (eql (eval right) (tail exp)))
          (list 'quote exp)
          (list 'quote (cons (eval left) (eval right)))))
       ((null? right) (list 'list left))
       ((and (list? right) (eq (head right) 'list))
        (cons 'list (cons left (tail right))))
       (else (list 'cons left right)))))

    (set expand-quasiquote (fn (exp nesting)
      (cond
       ((vector? exp)
        (list 'apply 'vec (expand-quasiquote (vector->list exp) nesting)))
       ((not (list? exp))
        (if (constant? exp) exp (list 'quote exp)))
       ((and (eq (head exp) 'unquote) (eq (length exp) 2))
        (if (eq nesting 0)
          (second exp)
          (combine-skeletons ''unquote (expand-quasiquote (tail exp) (- nesting 1)) exp)))
       ((and (eq (head exp) 'quasiquote) (eq (length exp) 2))
        (combine-skeletons ''quasiquote (expand-quasiquote (tail exp) (+ nesting 1)) exp))
       ((and (list? (head exp))
          (eq (head (head exp)) 'unquote-splicing)
          (eq (length (head exp)) 2))
        (if (eq nesting 0)
          (list 'append (second (first exp))
            (expand-quasiquote (tail exp) nesting))
          (combine-skeletons (expand-quasiquote (head exp) (- nesting 1))
            (expand-quasiquote (tail exp) nesting)
            exp)))
       (else (combine-skeletons
               (expand-quasiquote (head exp) nesting)
               (expand-quasiquote (tail exp) nesting)
               exp)))))

    (expand-quasiquote x 0)))

(set unquote (fn (& _) (error "unqote called outside of quasiquote")))
(set unquote-splicing (fn (& _) (error "unqote-splicing called outside of quasiquote")))

(set defmacro
  (macro (name args & body)
    `(do (set ,name (macro ,args ,@body))
         ',name)))

(defmacro defn (name args & body)
  `(do (set ,name (fn ,args ,@body))
       ',name))

(defn not (x) (eq x nil))
(defn identity (x) x)

(set = eql)

(defn > (x y) (< y x))
(defn >= (x y) (not (< x y)))
(defn <= (x y) (not (< y x)))
(defn /= (x y) (not (= x y)))

;(defmacro if (test then & else)
;  `(cond (,test ,then)
;         ,@(cond (else `((true ,@else))))))
;
;(defmacro when (test & body)
;  `(cond (,test ,@body)))
;
;(defmacro let (args & body)
;  ((fn (vars vals)
;     (defn vars (x)
;       (cond (x (cons (if (atom (car x))
;                          (car x)
;                        (caar x))
;                      (vars (cdr x))))))
;     (defn vals (x)
;       (cond (x (cons (if (atom (car x))
;                          nil
;                        (cadar x))
;                      (vals (cdr x))))))
;     `((lambda ,(vars args) ,@body) ,@(vals args)))
;   nil nil))
